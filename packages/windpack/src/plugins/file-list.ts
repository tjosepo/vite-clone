import type { ResolveData, javascript  } from 'webpack';
import { setError } from '../console/Errors.js';

export class FileListPlugin {
  options: any;
  
  static defaultOptions = {
    outputFile: 'assets.md',
  };

  // Any options should be passed in the constructor of your plugin,
  // (this is a public API of your plugin).
  constructor(options = {}) {
    // Applying user-specified options over the default options
    // and making merged options further available to the plugin methods.
    // You should probably validate all the options here as well.
    this.options = { ...FileListPlugin.defaultOptions, ...options };
  }

  apply(compiler: import('webpack').Compiler) {
    const pluginName = FileListPlugin.name;

    // webpack module instance can be accessed from the compiler object,
    // this ensures that correct version of the module is used
    // (do not require/import the webpack or any symbols from it directly).
    const { webpack } = compiler;

    // Compilation object gives us reference to some useful constants.
    const { Compilation } = webpack;

    // RawSource is one of the "sources" classes that should be used
    // to represent asset sources in compilation.
    const { RawSource } = webpack.sources;

    compiler.hooks.normalModuleFactory.tap(pluginName, (nmf) => {

      nmf.hooks.beforeResolve.tap(pluginName, (resolveData) => {
        if (resolveData.request.endsWith(".svg")) {
          // console.log("assertions", resolveData.request);;
          // console.log("resolveData", resolveData.assertions);
          // console.log("resolveData", resolveData);
        }
        
      });

      // nmf.hooks.createModule.tap(pluginName, (createModule, resolveData) => {
      //   if (resolveData.request.endsWith(".svg")) {
      //     console.log(resolveData)
      //   }
      // });
      // nmf.hooks.parser.for('javascript/auto').tap(pluginName, (parser: javascript.JavascriptParser) => {
      //   parser.hooks.import.tap(pluginName, (statement, source) => {
      //     if (source && !source.includes('node_modules')) {
      //       statement.
      //     console.log('statement', statement);
      //     console.log('source', source);
      //     }
      //   });
      // });
    });

    // Tapping to the "thisCompilation" hook in order to further tap
    // to the compilation process on an earlier stage.
    compiler.hooks.thisCompilation.tap(pluginName, (compilation) => {
      // Tapping to the assets processing pipeline on a specific stage.
      compilation.hooks.processAssets.tap(
        {
          name: pluginName,

          // Using one of the later asset processing stages to ensure
          // that all assets were already added to the compilation by other plugins.
          stage: Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE,
        },
        (assets) => {
          // "assets" is an object that contains all assets
          // in the compilation, the keys of the object are pathnames of the assets
          // and the values are file sources.

          // Iterating over all the assets and
          // generating content for our Markdown file.
          const content =
            '# In this build:\n\n' +
            Object.keys(assets)
              .map((filename) => `- ${filename} (${formatBytes(assets[filename].size())})`)
              .join('\n');
            
          // console.log(content)

          // Adding new asset to the compilation, so it would be automatically
          // generated by the webpack in the output directory.
          compilation.emitAsset(
            this.options.outputFile,
            new RawSource(content)
          );
        }
      );

    });
  }
}

function formatBytes(bytes: number, decimals = 2) {
  if (!+bytes) return '0 bytes'

  const k = 1024
  const dm = decimals < 0 ? 0 : decimals
  const sizes = ['bytes', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']

  const i = Math.floor(Math.log(bytes) / Math.log(k))

  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`
}
